---
title: "测试"
date: "2024-01-15"
author: "技术作者"
description: "一个包含完整目录结构和长代码示例的技术文章"
draft: true
categories: ["编程", "教程"]
tags: ["python", "fastapi", "sqlalchemy", "redis"]
---

# 测试文章：高级编程技巧与实践指南

## 目录

- [测试文章：高级编程技巧与实践指南](#测试文章高级编程技巧与实践指南)
  - [目录](#目录)
  - [引言](#引言)
  - [环境配置](#环境配置)
  - [项目结构](#项目结构)
  - [核心模块设计](#核心模块设计)
  - [数据模型定义](#数据模型定义)
  - [API接口设计](#api接口设计)
  - [数据库操作](#数据库操作)
  - [业务逻辑实现](#业务逻辑实现)
  - [错误处理机制](#错误处理机制)
  - [性能优化策略](#性能优化策略)
  - [安全防护措施](#安全防护措施)
  - [测试用例编写](#测试用例编写)
  - [部署配置](#部署配置)
  - [监控与日志](#监控与日志)
  - [总结与展望](#总结与展望)
  - [附录](#附录)
  - [代码示例](#代码示例)
- [-*- coding: utf-8 -*-](#---coding-utf-8---)
- [配置日志](#配置日志)
- [数据库配置](#数据库配置)
- [Redis配置](#redis配置)
- [安全配置](#安全配置)
- [监控指标](#监控指标)
- [SQLAlchemy 模型](#sqlalchemy-模型)
- [Pydantic 模型](#pydantic-模型)
- [依赖注入](#依赖注入)
- [工具函数](#工具函数)
- [业务逻辑类](#业务逻辑类)
- [FastAPI 应用](#fastapi-应用)
- [中间件](#中间件)
- [API路由](#api路由)
- [启动应用](#启动应用)

## 引言

本文旨在展示一个完整的企业级应用开发示例，包含复杂的代码结构和最佳实践。

## 环境配置

## 项目结构

## 核心模块设计

## 数据模型定义

## API接口设计

## 数据库操作

## 业务逻辑实现

## 错误处理机制

## 性能优化策略

## 安全防护措施

## 测试用例编写

## 部署配置

## 监控与日志

## 总结与展望

## 附录

## 代码示例

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
高级企业级应用示例
这是一个复杂的Python应用程序，展示了多种编程技术和设计模式
"""

import asyncio
import json
import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import List, Dict, Optional, Union, Any, Callable, Coroutine
from contextlib import asynccontextmanager
import aiohttp
import redis.asyncio as redis
from pydantic import BaseModel, ValidationError, validator
from sqlalchemy import create_engine, Column, Integer, String, DateTime, Text, ForeignKey, Boolean, Float, JSON
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, relationship, Session
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy.sql import select, update, delete, func
import uvicorn
from fastapi import FastAPI, HTTPException, Depends, BackgroundTasks, Query, Path, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import jwt
from passlib.context import CryptContext
import httpx
from prometheus_client import Counter, Histogram, generate_latest, CONTENT_TYPE_LATEST
import psutil
import os

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('app.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

# 数据库配置
DATABASE_URL = "postgresql+psycopg2://user:password@localhost:5432/mydatabase"
engine = create_engine(DATABASE_URL, pool_pre_ping=True, pool_recycle=3600)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# Redis配置
REDIS_URL = "redis://localhost:6379"
redis_pool = redis.ConnectionPool.from_url(REDIS_URL)

# 安全配置
SECRET_KEY = "your-secret-key-here-make-it-very-long-and-secure"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
security = HTTPBearer()

# 监控指标
REQUEST_COUNT = Counter('request_count', 'App Request Count', ['method', 'endpoint', 'http_status'])
REQUEST_LATENCY = Histogram('request_latency_seconds', 'Request latency', ['endpoint'])

class UserRole(str, Enum):
    ADMIN = "admin"
    USER = "user"
    MODERATOR = "moderator"

class UserStatus(str, Enum):
    ACTIVE = "active"
    INACTIVE = "inactive"
    SUSPENDED = "suspended"

# SQLAlchemy 模型
class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String(50), unique=True, index=True, nullable=False)
    email = Column(String(100), unique=True, index=True, nullable=False)
    hashed_password = Column(String(255), nullable=False)
    full_name = Column(String(100))
    role = Column(String(20), default=UserRole.USER)
    status = Column(String(20), default=UserStatus.ACTIVE)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    last_login = Column(DateTime)
    
    # 关系
    posts = relationship("Post", back_populates="author")
    comments = relationship("Comment", back_populates="author")

class Post(Base):
    __tablename__ = "posts"
    
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String(200), nullable=False)
    content = Column(Text, nullable=False)
    summary = Column(String(500))
    slug = Column(String(200), unique=True, index=True)
    is_published = Column(Boolean, default=False)
    published_at = Column(DateTime)
    author_id = Column(Integer, ForeignKey("users.id"))
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    view_count = Column(Integer, default=0)
    like_count = Column(Integer, default=0)
    
    # 关系
    author = relationship("User", back_populates="posts")
    comments = relationship("Comment", back_populates="post")
    tags = relationship("Tag", secondary="post_tags", back_populates="posts")

class Comment(Base):
    __tablename__ = "comments"
    
    id = Column(Integer, primary_key=True, index=True)
    content = Column(Text, nullable=False)
    author_id = Column(Integer, ForeignKey("users.id"))
    post_id = Column(Integer, ForeignKey("posts.id"))
    parent_id = Column(Integer, ForeignKey("comments.id"))
    is_approved = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # 关系
    author = relationship("User", back_populates="comments")
    post = relationship("Post", back_populates="comments")
    replies = relationship("Comment", backref=relationship("parent", remote_side=[id]))

class Tag(Base):
    __tablename__ = "tags"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(50), unique=True, nullable=False)
    slug = Column(String(50), unique=True, nullable=False)
    description = Column(String(200))
    
    posts = relationship("Post", secondary="post_tags", back_populates="tags")

class PostTag(Base):
    __tablename__ = "post_tags"
    
    post_id = Column(Integer, ForeignKey("posts.id"), primary_key=True)
    tag_id = Column(Integer, ForeignKey("tags.id"), primary_key=True)
    created_at = Column(DateTime, default=datetime.utcnow)

# Pydantic 模型
class UserBase(BaseModel):
    username: str
    email: str
    full_name: Optional[str] = None
    role: UserRole = UserRole.USER

class UserCreate(UserBase):
    password: str

class UserUpdate(BaseModel):
    email: Optional[str] = None
    full_name: Optional[str] = None
    role: Optional[UserRole] = None

class UserResponse(UserBase):
    id: int
    status: UserStatus
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True

class Token(BaseModel):
    access_token: str
    token_type: str
    expires_in: int

class TokenData(BaseModel):
    username: Optional[str] = None
    user_id: Optional[int] = None

class PostBase(BaseModel):
    title: str
    content: str
    summary: Optional[str] = None
    is_published: bool = False

class PostCreate(PostBase):
    tags: List[str] = []

class PostUpdate(BaseModel):
    title: Optional[str] = None
    content: Optional[str] = None
    summary: Optional[str] = None
    is_published: Optional[bool] = None

class PostResponse(PostBase):
    id: int
    slug: str
    author_id: int
    author: UserResponse
    published_at: Optional[datetime]
    created_at: datetime
    updated_at: datetime
    view_count: int
    like_count: int
    tags: List[str]
    
    class Config:
        from_attributes = True

# 依赖注入
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

async def get_redis():
    redis_client = redis.Redis(connection_pool=redis_pool)
    try:
        yield redis_client
    finally:
        await redis_client.close()

# 工具函数
def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = TokenData(username=username)
    except jwt.JWTError:
        raise credentials_exception
    
    user = db.query(User).filter(User.username == token_data.username).first()
    if user is None:
        raise credentials_exception
    return user

async def get_current_active_user(current_user: User = Depends(get_current_user)):
    if current_user.status != UserStatus.ACTIVE:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user

# 业务逻辑类
class UserService:
    def __init__(self, db: Session):
        self.db = db
    
    def create_user(self, user_create: UserCreate) -> User:
        # 检查用户是否存在
        if self.db.query(User).filter(User.username == user_create.username).first():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Username already registered"
            )
        
        if self.db.query(User).filter(User.email == user_create.email).first():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Email already registered"
            )
        
        hashed_password = get_password_hash(user_create.password)
        db_user = User(
            username=user_create.username,
            email=user_create.email,
            hashed_password=hashed_password,
            full_name=user_create.full_name,
            role=user_create.role
        )
        
        self.db.add(db_user)
        self.db.commit()
        self.db.refresh(db_user)
        return db_user
    
    def get_user_by_id(self, user_id: int) -> Optional[User]:
        return self.db.query(User).filter(User.id == user_id).first()
    
    def update_user(self, user_id: int, user_update: UserUpdate) -> Optional[User]:
        db_user = self.get_user_by_id(user_id)
        if not db_user:
            return None
        
        update_data = user_update.dict(exclude_unset=True)
        for field, value in update_data.items():
            setattr(db_user, field, value)
        
        db_user.updated_at = datetime.utcnow()
        self.db.commit()
        self.db.refresh(db_user)
        return db_user

class PostService:
    def __init__(self, db: Session, redis_client: redis.Redis):
        self.db = db
        self.redis = redis_client
    
    def create_slug(self, title: str) -> str:
        # 简单的slug生成逻辑
        slug = title.lower().replace(' ', '-')
        slug = ''.join(c for c in slug if c.isalnum() or c == '-')
        
        # 检查slug是否唯一
        counter = 1
        original_slug = slug
        while self.db.query(Post).filter(Post.slug == slug).first():
            slug = f"{original_slug}-{counter}"
            counter += 1
        
        return slug
    
    def create_post(self, post_create: PostCreate, author_id: int) -> Post:
        slug = self.create_slug(post_create.title)
        
        db_post = Post(
            title=post_create.title,
            content=post_create.content,
            summary=post_create.summary,
            slug=slug,
            is_published=post_create.is_published,
            author_id=author_id
        )
        
        if post_create.is_published:
            db_post.published_at = datetime.utcnow()
        
        # 处理标签
        for tag_name in post_create.tags:
            tag = self.db.query(Tag).filter(Tag.name == tag_name).first()
            if not tag:
                tag_slug = tag_name.lower().replace(' ', '-')
                tag = Tag(name=tag_name, slug=tag_slug)
                self.db.add(tag)
                self.db.flush()
            
            post_tag = PostTag(post_id=db_post.id, tag_id=tag.id)
            self.db.add(post_tag)
        
        self.db.add(db_post)
        self.db.commit()
        self.db.refresh(db_post)
        return db_post
    
    async def increment_view_count(self, post_id: int):
        # 使用Redis进行视图计数，定期同步到数据库
        redis_key = f"post:views:{post_id}"
        await self.redis.incr(redis_key)
        
        # 如果计数达到阈值，同步到数据库
        current_views = int(await self.redis.get(redis_key) or 0)
        if current_views % 10 == 0:  # 每10次视图同步一次
            self.db.query(Post).filter(Post.id == post_id).update(
                {"view_count": Post.view_count + current_views}
            )
            self.db.commit()
            await self.redis.set(redis_key, 0)

# FastAPI 应用
app = FastAPI(
    title="高级博客API",
    description="一个功能完整的博客系统API",
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

# 中间件
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "https://example.com"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# API路由
@app.post("/auth/register", response_model=UserResponse)
def register(
    user_create: UserCreate,
    db: Session = Depends(get_db)
):
    user_service = UserService(db)
    return user_service.create_user(user_create)

@app.post("/auth/login", response_model=Token)
def login(
    username: str,
    password: str,
    db: Session = Depends(get_db)
):
    user = db.query(User).filter(User.username == username).first()
    if not user or not verify_password(password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password"
        )
    
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )
    
    # 更新最后登录时间
    user.last_login = datetime.utcnow()
    db.commit()
    
    return Token(
        access_token=access_token,
        token_type="bearer",
        expires_in=ACCESS_TOKEN_EXPIRE_MINUTES * 60
    )

@app.post("/posts", response_model=PostResponse)
def create_post(
    post_create: PostCreate,
    current_user: User = Depends(get_current_active_user),
    db: Session = Depends(get_db),
    redis_client: redis.Redis = Depends(get_redis)
):
    post_service = PostService(db, redis_client)
    return post_service.create_post(post_create, current_user.id)

@app.get("/posts/{post_slug}", response_model=PostResponse)
async def get_post(
    post_slug: str = Path(..., description="文章的slug"),
    db: Session = Depends(get_db),
    redis_client: redis.Redis = Depends(get_redis)
):
    post = db.query(Post).filter(Post.slug == post_slug).first()
    if not post:
        raise HTTPException(status_code=404, detail="Post not found")
    
    # 异步增加视图计数
    post_service = PostService(db, redis_client)
    asyncio.create_task(post_service.increment_view_count(post.id))
    
    return post

@app.get("/metrics")
def metrics():
    return Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)

# 启动应用
if __name__ == "__main__":
    # 创建数据库表
    Base.metadata.create_all(bind=engine)
    
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="info"
    )